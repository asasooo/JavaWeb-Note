1、通过实现Runnable接口创建线程

(1).定义一个类实现Runnable接口，重写接口中的run()方法。在run()方法中加入具体的任务代码或处理逻辑。

(2).创建Runnable接口实现类的对象。

(3).创建一个Thread类的对象，需要封装前面Runnable接口实现类的对象。（接口可以实现多继承）

(4).调用Thread对象的start()方法，启动线程

[java] view plaincopy 
public class ThreadFromRunnable implements Runnable {  
  
    //static int count = 10;  
    public void run() {  
        int count = 10;  
        System.out.println("\t#"+Thread.currentThread().getName()+" got count from " + count);  
        while(count > 0)  
        {  
            System.out.println("#"+Thread.currentThread().getName()+" : "+ count--);  
        }  
        System.out.println("#"+Thread.currentThread().getName()+" : exiting "+ count--);  
    }  
    public static void main(String[] args)  
    {  
        ThreadFromRunnable tr = new ThreadFromRunnable();  
        Thread thread = new Thread(tr);  
        Thread thread2 = new Thread(tr);  
          
        thread.start();  
        thread2.start();  
    }  
  
}  
output：
#Thread-0 got count from 10
#Thread-1 got count from 10
#Thread-1 : 10
#Thread-1 : 9
#Thread-1 : 8
#Thread-1 : 7
#Thread-1 : 6
#Thread-1 : 5
#Thread-1 : 4
#Thread-0 : 10
#Thread-1 : 3
#Thread-0 : 9
#Thread-1 : 2
#Thread-0 : 8
#Thread-1 : 1
#Thread-0 : 7
#Thread-1 : exiting 0
#Thread-0 : 6
#Thread-0 : 5
#Thread-0 : 4
#Thread-0 : 3
#Thread-0 : 2
#Thread-0 : 1
#Thread-0 : exiting 0



2、通过继承Thread类创建线程

(1).首先定义一个类去继承Thread父类，重写父类中的run()方法。在run()方法中加入具体的任务代码或处理逻辑。
(2).直接创建一个ThreadDemo2类的对象，也可以利用多态性，变量声明为父类的类型。

(3).调用start方法，线程t启动，隐含的调用run()方法。


[java] view plaincopy 
public class ThreadExtendsThread extends Thread {  
    //static int count =10;  
    public void run()  
    {  
        int count =10;  
        System.out.println("\t#"+Thread.currentThread().getName()+" got count from " + count);  
        while(count > 0)  
        {  
            System.out.println("{1}quot;+this.getName()+" : "+count--);  
        }  
        System.out.println("{1}quot;+this.getName()+" : existing count=" + count);  
    }  
      
    public static void main(String[] args)  
    {  
        ThreadExtendsThread thread = new ThreadExtendsThread();  
        ThreadExtendsThread thread2 = new ThreadExtendsThread();  
        thread.start();  
        thread2.start();  
    }  
}  
output：
#Thread-0 got count from 10
#Thread-1 got count from 10
$Thread-1 : 10
$Thread-1 : 9
$Thread-1 : 8
$Thread-1 : 7
$Thread-1 : 6
$Thread-1 : 5
$Thread-1 : 4
$Thread-1 : 3
$Thread-1 : 2
$Thread-1 : 1
$Thread-0 : 10
$Thread-1 : existing count=0
$Thread-0 : 9
$Thread-0 : 8
$Thread-0 : 7
$Thread-0 : 6
$Thread-0 : 5
$Thread-0 : 4
$Thread-0 : 3
$Thread-0 : 2
$Thread-0 : 1
$Thread-0 : existing count=0


3、两种方式的比较

首先分析两种方式的输出结果，同样是创建了两个线程，为什么结果不一样呢？

使用实现Runnable接口方式创建线程可以共享同一个目标对象（TreadDemo1 tt=new TreadDemo1();），实现了多个相同线程处理同一份资源。

然后再看一段来自JDK的解释：


The Runnable interface should be implemented by any class whose instances are intended to be executed by a thread. The class must define a method of no arguments calledrun.
This interface is designed to provide a common protocol for objects that wish to execute code while they are active. For example,Runnable is implemented by classThread. Being active simply means that a thread has been started and has not yet been stopped.
In addition, Runnable provides the means for a class to be active while not subclassingThread. A class that implementsRunnable can run without subclassingThread by instantiating aThread instance and passing itself in as the target. In most cases, theRunnable interface should be used if you are only planning to override therun() method and no otherThread methods. This is important because classes should not be subclassed unless the programmer intends on modifying or enhancing the fundamental behavior of the class.

采用继承Thread类方式：
（1）优点：编写简单，如果需要访问当前线程，无需使用Thread.currentThread()方法，直接使用this，即可获得当前线程。
（2）缺点：因为线程类已经继承了Thread类，所以不能再继承其他的父类。
采用实现Runnable接口方式：
（1）优点：线程类只是实现了Runable接口，还可以继承其他的类。在这种方式下，可以多个线程共享同一个目标对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。
（2）缺点：编程稍微复杂，如果需要访问当前线程，必须使用Thread.currentThread()方法