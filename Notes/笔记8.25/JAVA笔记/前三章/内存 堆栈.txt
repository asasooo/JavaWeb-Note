局部变量 栈分配
syntax	 语法

构造函数不存在 返回类型，函数名与所在类的类名一致；
 
 		long num = n.nextLong();
		String a = Long.toString(num);
		char[] b = a.toCharArray();


 Integer.parseInt（String）：该方法的用途是将字符串参数作为有符号的十进制整数进行解析。 

平均  average

首先解释最简单的codeseg  这是代码区，顾名思义就是存储代码的。
dateseg 存储静态的成员变量和字符串常量。
堆 存储对象的引用，也就是new出来的东西。
栈 存储局部变量以及方法的参数等
方法参数、局部变量存放在栈内存中的栈

Java自动管理栈和堆

堆 和 栈 的理解：
栈就像装数据的桶或箱子

我们先从大家比较熟悉的栈说起吧，它是一种具有后进先出性质的数据结构，也就是说后存放的先取，先存放的后取。

这就如同我们要取出放在箱子里面底下的东西（放入的比较早的物体），我们首先要移开压在它上面的物体（放入的比较晚的物体）。

堆像一棵倒过来的树

而堆就不同了，堆是一种经过排序的树形数据结构，每个结点都有一个值。
通常我们所说的堆的数据结构，是指二叉堆。
堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。
由于堆的这个特性，常用来实现优先队列，堆的存取是随意，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，
但是我们想取任意一本时不必像栈一样，先取出前面所有的书，书架这种机制不同于箱子，我们可以直接取出我们想要的书。

局部变量和全局变量:
	在子程序中定义的变量称为局部变量，在程序的一开始定义的变量称为全局变量。
	全局变量作用域是整个程序，局部变量作用域是定义该变量的子程序。
	当全局变量与局部变量同名时：在定义局部变量的子程序内，局部变量起作用；在其它地方全局变量起作用。
	main方法也是方法，所以定义在main方法中的变量也是局部变量

带static就是在静态存储区,反之不是
当我们实例化一个类的时候,首先会创建静态的属性于静态存储区,
之后会创建类所属的属性,就是你说的全局变量于栈中,
如果属性为8种基本数据类型,则栈中存放值,
反之,栈中存放指向堆内存的地址


另外，栈有一个很重要的特殊性，就是存在栈中的数据可以共享。int a =3 ; int b= 3; 
b====>3<=====a  同一个


String是一个特殊的包装类数据。即可以用String str = new String("abc");的形式来创建，也可以用String str = "abc"来创建。auto特性boxing

包装类数据=====》堆  （例如：String省略new（）过程）


String s=“qq”=====>字符串缓冲池
String s = new String("dd")=====>堆

equal 与 == 区别：
  equal
  == ： 比较内存地址是否相等



e1：
<code class="hljs" cs="">
public static void main(String[] args) { 
        String s1 = Monday; 
        String s2 = new String(Monday); 
        if (s1 == s2) 
            System.out.println(s1 == s2); 
        else
            System.out.println(s1 != s2); 
        if (s1.equals(s2)) 
            System.out.println(s1 equals s2); 
        else
            System.out.println(s1 not equals s2); 
    } </code>

结果：
s1 != s2
s1 equals s2
分析：先来说说intern（）这个方法的作用吧，这个方法的作用是返回在字符串缓冲池中的对象的引用，所以s2指向的也是字符串缓冲池中的地址，
和s1是相等的。
	当 a.equals(b)时 a=a.intern();a==b 为true；

java的内存机制
 
Java 把内存划分成两种：一种是栈内存，另一种是堆内存。在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配，当在一段代码块定义一个变量时，Java 就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java 会自动释放掉为该变量分配的内存空间，该内存空间可以立即被另作它用。
　　堆内存用来存放由 new 创建的对象和数组，在堆中分配的内存，由 Java 虚拟机的自动垃圾回收器来管理。在堆中产生了一个数组或者对象之后，还可以在栈中定义一个特殊的变量，让栈中的这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或者对象，引用变量就相当于是为数组或者对象起的一个名称。引用变量是普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域之外后被释放。而数组和对象本身在堆中分配，即使程序运行到使用 new 产生数组或者对象的语句所在的代码块之外，数组和对象本身占据的内存不会被释放，数组和对象在没有引用变量指向它的时候，才变为垃圾，不能在被使用，但仍然占据内存空间不放，在随后的一个不确定的时间被垃圾回收器收走（释放掉）。
　　这也是 Java 比较占内存的原因，实际上，栈中的变量指向堆内存中的变量，这就是 Java 中的指针！

