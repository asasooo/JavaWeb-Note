  jaxp修改节点
	修改第一个p下面的sex内容是男
	java文件：
	public static void modifySex() throws Exception {   modify――修改
		1,创建解析器工厂 解析器     
		2，解析xml 返回document
		3，得到sex item方法
		4，修改sex里面的值
		5，setTextContent 方法 
		6，回写xml文件
	DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();	
	DocumentBuilder db = dbf.newDocumentBuilder();
	Document doc = db.parse("文件路径") ;   parse ―― 从文本分析
	Node sex = doc.getElementsByName().item(第几个);
	sex.setTextContent("修改该内容");
	TransformerFactory tf = TransformerFactory.newInstance();
	Transformer t = tf.newTransformer();
	t.transform(new DOMSource(document),new StreamResult("修改xml的地址"));
	
  jaxp删除节点  sex节点
	DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
	DocumentBuilder db = dbf.newDocumentBuilder();
	Document doc = db.parse("xml地址");
	Node sex1 = doc.getElementsByTagName("sex").item(0);
	Node parent = sex1.getParentNode();
	parent.removeChilder(sex1);
	TransformerFactory tf = TransformerFactory.newInstance();
	Transformer t = tf.Transformer();
	t.transform(new DOMSource(document),new StreamResult("src//person.xml"));
	
  jaxp遍历节点
	打印出所有节点
	DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
	DocumentBuilder db = dbf.newDocumentBuilder();
	Document doc = db.parse("src//person.xml");
	//编写一个方法进行遍历
	list(doc);
		
	public static void list(Node doc){
		if(doc.getNodeType() == Node.ELEMENT_NODE){  判断是不是element类型 
			NodeList li = doc.getChildNodes();
			for(int i = 0 ;i<list.getLength();i++){
				Node node1 = list.item(i);
				//继续得到node1的子节点
				list(node1);  使用递归方法。自己调用自己。 
			//xml解析会把所有东西都解析出来
			}	
		}

	总结：
		jaxp是重点
		表单提交方式 buttom提交  超链接提交  事件
		xml的文档声明 <?xml version="1.0" encoding="utf-8"?>  必须放在第一行
		CDATA与PI
		dtd约束 schema约束
			#PCDATA 字符串
			#REQUIRED 必须出现
			
		xml解析  dom容易内存溢出 可以增删改
			sax不能操作 
			获取全部元素getElementsByTagName返回的是数组
			setTextContent 修改标签里的内容
			getParentNode removeChild
			递归遍历方法 
	